---
description: 
globs: 
alwaysApply: true
---
# Code Quality Standards for Book Reviews

## ğŸ¯ Purpose
This rule ensures all code examples in book reviews maintain high quality, are educational, and follow best practices for learning and understanding.

## ğŸ“ Referenced Files
- Main structure: [README.md](mdc:README.md)
- Template: [Template.md](mdc:Template.md)
- Example implementations in: `ds-the-fun-way/`, `five-lines-of-code/`, `ë¦¬ì•¡íŠ¸-í›…ì„-í™œìš©í•œ-ë§ˆì´í¬ë¡œ-ìƒíƒœ-ê´€ë¦¬/`

## ğŸš¨ CRITICAL CODE RULES - MUST FOLLOW

### 1. Code Documentation Standards
- **MUST include Korean comments** explaining the logic
- **MUST specify time complexity** for algorithms
- **MUST include space complexity** when relevant
- **MUST explain the purpose** of each function/class

### 2. Code Structure Requirements
```typescript
// âœ… CORRECT FORMAT
/**
 * í•¨ìˆ˜ ì„¤ëª… (í•œêµ­ì–´)
 * @param input - ì…ë ¥ê°’ ì„¤ëª…
 * @returns ë°˜í™˜ê°’ ì„¤ëª…
 * @timeComplexity O(n) - ì‹œê°„ë³µì¡ë„ ì„¤ëª…
 * @spaceComplexity O(1) - ê³µê°„ë³µì¡ë„ ì„¤ëª…
 */
function exampleFunction(input: string): number {
  // êµ¬í˜„ ë¡œì§ ì„¤ëª…
  const result = input.length;
  
  // ê²°ê³¼ ë°˜í™˜
  return result;
}
```

### 3. Algorithm Implementation Standards
- **MUST include step-by-step comments** for complex algorithms
- **MUST show edge cases** and how they're handled
- **MUST demonstrate optimization techniques** when applicable
- **MUST connect to real-world use cases**

## âŒ CODE VIOLATIONS - STRICTLY FORBIDDEN

### 1. Documentation Violations
- **NEVER write code without Korean comments**
- **NEVER skip time complexity analysis**
- **NEVER omit function purpose explanation**
- **NEVER use unclear variable names**

### 2. Implementation Violations
- **NEVER write inefficient code** without explaining why
- **NEVER skip error handling** for critical operations
- **NEVER use magic numbers** without explanation
- **NEVER create code that doesn't compile/run**

### 3. Educational Violations
- **NEVER skip the learning connection** to real-world scenarios
- **NEVER omit comparison** with alternative approaches
- **NEVER skip performance implications** explanation

## âœ… BEST PRACTICES FOR CODE EXAMPLES

### 1. Algorithm Explanations
```typescript
// âœ… GOOD EXAMPLE
/**
 * ì‚½ì… ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
 * ë°°ì—´ì˜ ì•ë¶€ë¶„ì„ ì •ë ¬ëœ ìƒíƒœë¡œ ìœ ì§€í•˜ë©´ì„œ
 * ìƒˆë¡œìš´ ìš”ì†Œë¥¼ ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…í•˜ëŠ” ë°©ì‹
 * 
 * @param arr - ì •ë ¬í•  ë°°ì—´
 * @returns ì •ë ¬ëœ ë°°ì—´
 * @timeComplexity O(nÂ²) - ìµœì•…ì˜ ê²½ìš°
 * @spaceComplexity O(1) - ì œìë¦¬ ì •ë ¬
 */
function insertionSort(arr: number[]): number[] {
  const n = arr.length;
  
  // ë‘ ë²ˆì§¸ ìš”ì†Œë¶€í„° ì‹œì‘ (ì²« ë²ˆì§¸ëŠ” ì´ë¯¸ ì •ë ¬ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼)
  for (let i = 1; i < n; i++) {
    const current = arr[i]; // í˜„ì¬ ì‚½ì…í•  ìš”ì†Œ
    let j = i - 1; // ì •ë ¬ëœ ë¶€ë¶„ì˜ ë§ˆì§€ë§‰ ì¸ë±ìŠ¤
    
    // ì •ë ¬ëœ ë¶€ë¶„ì—ì„œ currentë³´ë‹¤ í° ìš”ì†Œë“¤ì„ ë’¤ë¡œ ì´ë™
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    
    // currentë¥¼ ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…
    arr[j + 1] = current;
  }
  
  return arr;
}
```

### 2. Data Structure Examples
```typescript
// âœ… GOOD EXAMPLE
/**
 * ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë…¸ë“œ í´ë˜ìŠ¤
 * ë°ì´í„°ì™€ ë‹¤ìŒ ë…¸ë“œì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ì €ì¥
 */
class ListNode<T> {
  constructor(
    public data: T,
    public next: ListNode<T> | null = null
  ) {}
}

/**
 * ì—°ê²° ë¦¬ìŠ¤íŠ¸ í´ë˜ìŠ¤
 * ë…¸ë“œë“¤ì„ ì—°ê²°í•˜ì—¬ ì„ í˜• ë°ì´í„° êµ¬ì¡°ë¥¼ ë§Œë“¦
 * 
 * @timeComplexity ì ‘ê·¼: O(n), ì‚½ì…/ì‚­ì œ: O(1) (í—¤ë“œì—ì„œ)
 * @spaceComplexity O(n) - nê°œì˜ ë…¸ë“œ
 */
class LinkedList<T> {
  private head: ListNode<T> | null = null;
  
  /**
   * ë¦¬ìŠ¤íŠ¸ì˜ ë§¨ ì•ì— ìƒˆ ë…¸ë“œ ì¶”ê°€
   * @param data - ì¶”ê°€í•  ë°ì´í„°
   */
  prepend(data: T): void {
    const newNode = new ListNode(data, this.head);
    this.head = newNode;
  }
}
```

### 3. React Hook Examples
```typescript
// âœ… GOOD EXAMPLE
/**
 * ì¹´ìš´í„° ì»¤ìŠ¤í…€ í›…
 * ìƒíƒœ ê´€ë¦¬ ë¡œì§ì„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ë¶„ë¦¬í•˜ì—¬ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ë§Œë“¦
 * 
 * @param initialValue - ì´ˆê¸°ê°’
 * @returns [í˜„ì¬ê°’, ì¦ê°€í•¨ìˆ˜, ê°ì†Œí•¨ìˆ˜, ë¦¬ì…‹í•¨ìˆ˜]
 */
function useCounter(initialValue: number = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  const decrement = useCallback(() => {
    setCount(prev => prev - 1);
  }, []);
  
  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);
  
  return [count, increment, decrement, reset] as const;
}
```

## ğŸ”§ Technical Requirements

### 1. TypeScript Standards
- **MUST use proper type annotations**
- **MUST handle null/undefined cases**
- **MUST use interfaces for complex objects**
- **MUST demonstrate generic types** when relevant

### 2. Performance Considerations
- **MUST explain Big O notation** for algorithms
- **MUST show optimization techniques**
- **MUST compare different approaches**
- **MUST mention memory usage** when significant

### 3. Real-World Connections
- **MUST link to LeetCode problems** when applicable
- **MUST show practical use cases**
- **MUST connect to work experiences**
- **MUST demonstrate industry best practices**

## ğŸ“‹ Code Quality Checklist
- [ ] Korean comments included
- [ ] Time complexity specified
- [ ] Space complexity mentioned
- [ ] Function purpose explained
- [ ] Edge cases handled
- [ ] Real-world connections made
- [ ] Performance implications discussed
- [ ] Alternative approaches compared
- [ ] Code is educational and clear
- [ ] Follows TypeScript best practices
